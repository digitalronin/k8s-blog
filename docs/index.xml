<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K8S DigitalRonin</title>
    <link>http://k8s.digitalronin.com/</link>
    <description>Recent content on K8S DigitalRonin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 May 2019 20:11:19 +0100</lastBuildDate>
    
	<atom:link href="http://k8s.digitalronin.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rails on Kubernetes - part 4: Docker Compose</title>
      <link>http://k8s.digitalronin.com/posts/rails-on-k8s-docker-compose/</link>
      <pubDate>Mon, 13 May 2019 20:11:19 +0100</pubDate>
      
      <guid>http://k8s.digitalronin.com/posts/rails-on-k8s-docker-compose/</guid>
      <description>This is one of a series of blog posts in which I&amp;rsquo;m walking through the process of deploying a rails application to a kubernetes cluster. Part one is here, and the previous article is here.
 To test our containerised Rails app locally, before we try to deploy it to our kubernetes cluster, we can use docker-compose.
First of all, stop the postgresql container, otherwise things might get confusing:</description>
    </item>
    
    <item>
      <title>Rails on Kubernetes - part 3: Dockerise</title>
      <link>http://k8s.digitalronin.com/posts/rails-on-k8s-dockerise/</link>
      <pubDate>Mon, 06 May 2019 20:11:19 +0100</pubDate>
      
      <guid>http://k8s.digitalronin.com/posts/rails-on-k8s-dockerise/</guid>
      <description>This is one of a series of blog posts in which I&amp;rsquo;m walking through the process of deploying a rails application to a kubernetes cluster. Part one is here, and the previous article is here.
 Kubernetes runs containers, so before we can deploy our application to kubernetes, we need to containerise it.
In this section, we&amp;rsquo;re going to take our rails application and package it up as a Docker image.</description>
    </item>
    
    <item>
      <title>Rails on Kubernetes - part 2a: The Counter App.</title>
      <link>http://k8s.digitalronin.com/posts/rails-on-k8s-create-app2/</link>
      <pubDate>Tue, 30 Apr 2019 20:11:07 +0100</pubDate>
      
      <guid>http://k8s.digitalronin.com/posts/rails-on-k8s-create-app2/</guid>
      <description>This is one of a series of blog posts in which I&amp;rsquo;m walking through the process of deploying a rails application to a kubernetes cluster. Part one is here, and the previous article is here
 Our rails application can connect to our database. So now let&amp;rsquo;s get it to do what we want, which is to store and display a value, and increment it whenever we click a button.</description>
    </item>
    
    <item>
      <title>Rails on Kubernetes - part 2: Create the app</title>
      <link>http://k8s.digitalronin.com/posts/rails-on-k8s-create-app/</link>
      <pubDate>Tue, 23 Apr 2019 20:11:07 +0100</pubDate>
      
      <guid>http://k8s.digitalronin.com/posts/rails-on-k8s-create-app/</guid>
      <description>This is the second part of a series of posts on how to deploy a ruby on rails application to a kubernetes cluster. If you want to start from the beginning, part one is here
 Now that we have our kubernetes cluster, we need to create something to deploy onto it.
For this walkthrough, I&amp;rsquo;m going to create a trivial rails application, which just stores a counter in a database, and allows you to increment it by clicking a button.</description>
    </item>
    
    <item>
      <title>Rails on Kubernetes - part 1: Setup</title>
      <link>http://k8s.digitalronin.com/posts/rails-on-k8s-setup/</link>
      <pubDate>Tue, 16 Apr 2019 20:10:47 +0100</pubDate>
      
      <guid>http://k8s.digitalronin.com/posts/rails-on-k8s-setup/</guid>
      <description>This is part one of a series of posts in which I&amp;rsquo;m going to walk through the process of deploying a Ruby on Rails application to Kubernetes.
In this post, we&amp;rsquo;re going to use a one-node kubernetes cluster, running on your local development machine. One of the great things about kubernetes is that, from the point of view of your code, all clusters are the same. So, if we write code to deploy our application on a local development cluster, that same code should work just fine when we deploy it to our production cluster.</description>
    </item>
    
  </channel>
</rss>